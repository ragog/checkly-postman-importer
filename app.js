const axios = require('axios');
const yargs = require('yargs');
const fs = require('fs');
const { option } = require('yargs');

(async () => {
	const checklyApiKey = process.env.CHECKLY_API_KEY;
	const checklyAccountId = process.env.CHECKLY_ACCOUNT_ID;

	// Command line arguments
	const options = yargs
		.usage('Usage: -c <path_to_postman_collection>')
		.option('p', {
			alias: 'path',
			describe: 'Path to the Postman collection you want to import',
			type: 'string',
			demandOption: true,
		})
		.option('e', {
			alias: 'envvar',
			describe: 'Path to the Postman environment variable json you want to import',
			type: 'string',
			demandOption: false,
		}).argv;

	const collectionPath = options.p;

	// Environment variable file import (Optional)
	if (option.e) {
		let environmentVarsJson = fs.readFileSync(option.e);
		const environmentVarsJsonObj = JSON.parse(environmentVarsJson);
		const envVariables = environmentVarsJsonObj.values;

		// NOTE: skips variables with empty value
		for (let envVariable of envVariables) {
			if (envVariable.value) {
				await instance({
					method: 'post',
					url: '/v1/variables',
					data: {
						key: envVariable.key,
						value: envVariable.value,
						locked: false,
					},
				});
			}
		}
	}

	// Collection import
	let collectionJson = fs.readFileSync(collectionPath);
	const collectionJsonObj = JSON.parse(collectionJson);
	const folders = collectionJsonObj.item;

	console.log('Importing collection ' + collectionJsonObj.info.name)

	// Axios config
	const instance = axios.create({
		baseURL: 'https://api.checklyhq.com',
		headers: {
			Authorization: `Bearer ${checklyApiKey}`,
			'X-Checkly-Account': checklyAccountId,
			'Content-Type': 'application/json',
		},
	});

	// Postman Folder -> Checkly Groups
	for (let folder of folders) {
		const checks = folder.item;
		const response = await instance({
			method: 'post',
			url: '/v1/check-groups',
			data: {
				name: folder.name,
				activated: true,
				muted: false,
				sslCheck: false,
				doubleCheck: true,
				locations: ['us-east-1', 'eu-central-1'],
				alertSettings: {
					escalationType: 'RUN_BASED',
					runBasedEscalation: {
						failedRunThreshold: 1,
					},
					timeBasedEscalation: {
						minutesFailingThreshold: 5,
					},
					reminders: {
						amount: 0,
						interval: 5,
					},
					sslCertificates: {
						enabled: true,
						alertThreshold: 30,
					},
				},
				alertChannelSubscriptions: [],
				useGlobalAlertSettings: true,
			},
		});

		const groupId = response.data.id;

		for (let check of checks) {
			console.log(`Adding check ${check.name}`);

			const checkName = check.name;
			const request = check.request;
			const requestMethod = request.method;
			const requestUrl = request.url;
			let requestUrlRaw = requestUrl.raw;

			const urlVariables = requestUrlRaw.match(':[a-zA-Z]*');
			if (urlVariables && requestUrl.variable) {
				for (variable of requestUrl.variable) {
					requestUrlRaw = requestUrlRaw.replace(':' + variable.key, variable.value);
				}
			}

			const requestBodyMode = check.request.body ? check.request.body.mode : undefined;
			const requestBody = check.request.body ? check.request.body.raw : ''; // TODO: only handles raw
			const oldRequestHeaders = check.request.header;
			const postmanDefaultHeaders = [
				// autogenerated by Postman
				{ key: 'User-Agent', value: 'Checkly' }, // changed to Checkly
				{ key: 'Accept', value: '*/*' },
				{ key: 'Accept-Encoding', value: 'gzip, deflate, br' },
				{ key: 'Connection', value: 'keep-alive' },
			];
			const newRequestHeaders = postmanDefaultHeaders;
			const oldQueryParams = check.request.url.query;
			const newQueryParams = [];

			for (let oldHeader of oldRequestHeaders) {
				if (oldHeader.key) {
					const newHeader = {
						key: oldHeader.key,
						value: oldHeader.value,
					};
					newRequestHeaders.push(newHeader);
				}
			}

			if (oldQueryParams) {
				for (let oldQueryParam of oldQueryParams) {
					if (!oldQueryParam.disabled) {
						const newQueryParam = {
							key: oldQueryParam.key,
							value: oldQueryParam.value,
						};
						newQueryParams.push(newQueryParam);
					}
				}
			}

			const basicAuthUsername = request.auth?.basic[0]?.value;
			const basicAuthPassword = request.auth?.basic[0]?.value;

			const finishedCheck = {
				name: checkName,
				groupId: groupId,
				checkType: 'API',
				frequency: 10,
				activated: true,
				muted: false,
				doubleCheck: true,
				sslCheck: false,
				shouldFail: false,
				locations: ['us-east-1', 'eu-central-1'],
				request: {
					method: requestMethod,
					url: requestUrlRaw,
					followRedirects: true,
					body: requestBody,
					bodyType: 'RAW',
					headers: newRequestHeaders,
					queryParameters: newQueryParams,
					assertions: [],
					basicAuth: {
						username: basicAuthUsername ? basicAuthUsername : '',
						password: basicAuthPassword ? basicAuthPassword : '',
					},
				},
				alertSettings: {
					escalationType: 'RUN_BASED',
					runBasedEscalation: {
						failedRunThreshold: 1,
					},
					timeBasedEscalation: {
						minutesFailingThreshold: 5,
					},
					reminders: {
						amount: 0,
						interval: 5,
					},
					sslCertificates: {
						enabled: true,
						alertThreshold: 30,
					},
				},
				useGlobalAlertSettings: true,
				degradedResponseTime: 10000,
				maxResponseTime: 20000,
			}

			await instance({
				method: 'post',
				url: '/v1/checks',
				data: finishedCheck,
			})
		}
	}
})();
